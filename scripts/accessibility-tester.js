/**
 * Ï¢ÖÌï© Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ ÏûêÎèôÌôî Ïä§ÌÅ¨Î¶ΩÌä∏
 * axe-core, Pa11y, Lighthouse Ï†ëÍ∑ºÏÑ± Îì±ÏùÑ ÌÜµÌï© Í≤ÄÏÇ¨
 */

const fs = require('fs');
const path = require('path');
const { chromium } = require('playwright');
const axeCore = require('axe-core');
const { execSync } = require('child_process');

class AccessibilityTester {
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || 'http://localhost:4173';
    this.outputDir = options.outputDir || './accessibility-reports';
    this.wcagLevel = options.wcagLevel || 'AA';
    this.wcagVersion = options.wcagVersion || '2.1';
    
    this.thresholds = {
      compliance: options.compliance || 95, // WCAG Ï§ÄÏàòÏú® %
      violations: {
        critical: options.critical || 0,
        serious: options.serious || 2,
        moderate: options.moderate || 5,
        minor: options.minor || 10
      },
      colorContrast: options.colorContrast || 4.5,
      keyboardNavigation: options.keyboardNavigation || 100, // %
      ...options.thresholds
    };
    
    this.results = {
      axe: {},
      pa11y: {},
      lighthouse: {},
      keyboard: {},
      colorContrast: {},
      screenReader: {},
      summary: {},
      passed: false
    };
  }

  /**
   * Ï†ÑÏ≤¥ Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ Ïã§Ìñâ
   */
  async run() {
    console.log('‚ôø Ï¢ÖÌï© Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ ÏãúÏûë...');
    
    try {
      // Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
      await this.ensureOutputDirectory();
      
      // 1. axe-core Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨
      await this.runAxeTests();
      
      // 2. Pa11y Ï†ëÍ∑ºÏÑ± Ïä§Ï∫î
      await this.runPa11yTests();
      
      // 3. Lighthouse Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨
      await this.runLighthouseAccessibility();
      
      // 4. ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÖåÏä§Ìä∏
      await this.testKeyboardNavigation();
      
      // 5. ÏÉâÏÉÅ ÎåÄÎπÑ Í≤ÄÏÇ¨
      await this.checkColorContrast();
      
      // 6. Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ìò∏ÌôòÏÑ± Í≤ÄÏÇ¨
      await this.testScreenReaderCompatibility();
      
      // 7. Í≤∞Í≥º Î∂ÑÏÑù Î∞è Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
      await this.generateReport();
      
      // 8. ÏûÑÍ≥ÑÍ∞í Í≤ÄÏ¶ù
      this.validateThresholds();
      
      console.log('‚úÖ Ï¢ÖÌï© Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ ÏôÑÎ£å');
      return this.results;
      
    } catch (error) {
      console.error('‚ùå Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ Ïã§Ìå®:', error);
      this.results.passed = false;
      throw error;
    }
  }

  /**
   * axe-core Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨ Ïã§Ìñâ
   */
  async runAxeTests() {
    console.log('üîç axe-core Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨ Ï§ë...');
    
    const browser = await chromium.launch();
    const page = await browser.newPage();
    
    try {
      // axe-core Ïä§ÌÅ¨Î¶ΩÌä∏ Ï£ºÏûÖ
      await page.addScriptTag({ 
        path: require.resolve('axe-core/axe.min.js')
      });
      
      const testPages = [
        { name: 'Home', url: this.baseUrl },
        { name: 'Todo List', url: `${this.baseUrl}/` },
        // ÌïÑÏöîÏóê Îî∞Îùº Ï∂îÍ∞Ä ÌéòÏù¥ÏßÄ Ï†ïÏùò
      ];
      
      const axeResults = [];
      
      for (const testPage of testPages) {
        console.log(`  üìÑ ${testPage.name} ÌéòÏù¥ÏßÄ Í≤ÄÏÇ¨ Ï§ë...`);
        
        await page.goto(testPage.url, { waitUntil: 'networkidle' });
        
        // axe-core Ïã§Ìñâ
        const result = await page.evaluate(async (wcagLevel, wcagVersion) => {
          return await axe.run(document, {
            tags: [`wcag${wcagVersion.replace('.', '')}${wcagLevel.toLowerCase()}`],
            rules: {
              'color-contrast': { enabled: true },
              'keyboard-navigation': { enabled: true },
              'focus-order': { enabled: true },
              'bypass-blocks': { enabled: true }
            }
          });
        }, this.wcagLevel, this.wcagVersion);
        
        // Í≤∞Í≥º Ï≤òÎ¶¨
        const pageResult = {
          name: testPage.name,
          url: testPage.url,
          violations: result.violations.map(violation => ({
            id: violation.id,
            impact: violation.impact,
            description: violation.description,
            help: violation.help,
            helpUrl: violation.helpUrl,
            nodes: violation.nodes.length,
            tags: violation.tags
          })),
          passes: result.passes.length,
          incomplete: result.incomplete.length,
          inapplicable: result.inapplicable.length,
          timestamp: new Date().toISOString()
        };
        
        axeResults.push(pageResult);
      }
      
      // Ï†ÑÏ≤¥ Í≤∞Í≥º ÏßëÍ≥Ñ
      const totalViolations = axeResults.reduce((acc, page) => acc + page.violations.length, 0);
      const totalPasses = axeResults.reduce((acc, page) => acc + page.passes, 0);
      const totalTests = totalViolations + totalPasses;
      
      const violationsBySeverity = axeResults.reduce((acc, page) => {
        page.violations.forEach(violation => {
          const severity = this.mapAxeSeverity(violation.impact);
          acc[severity] = (acc[severity] || 0) + 1;
        });
        return acc;
      }, {});
      
      this.results.axe = {
        pages: axeResults,
        summary: {
          totalViolations,
          totalPasses,
          totalTests,
          complianceRate: totalTests > 0 ? Math.round((totalPasses / totalTests) * 100) : 100,
          violationsBySeverity
        }
      };
      
      // ÏÉÅÏÑ∏ Í≤∞Í≥º Ï†ÄÏû•
      fs.writeFileSync(
        path.join(this.outputDir, 'axe-results.json'),
        JSON.stringify(this.results.axe, null, 2)
      );
      
      console.log('  ‚úÖ axe-core Í≤ÄÏÇ¨ ÏôÑÎ£å');
      
    } finally {
      await browser.close();
    }
  }

  /**
   * Pa11y Ï†ëÍ∑ºÏÑ± Ïä§Ï∫î Ïã§Ìñâ
   */
  async runPa11yTests() {
    console.log('üîç Pa11y Ï†ëÍ∑ºÏÑ± Ïä§Ï∫î Ï§ë...');
    
    try {
      // Pa11y ÏÑ§Ïπò ÌôïÏù∏
      execSync('which pa11y', { stdio: 'ignore' });
    } catch {
      console.warn('  ‚ö†Ô∏è Pa11yÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïÑ Í±¥ÎÑàÎúÅÎãàÎã§.');
      this.results.pa11y = { skipped: true };
      return;
    }
    
    try {
      const pa11yConfig = {
        standard: `WCAG${this.wcagVersion}${this.wcagLevel}`,
        ignore: [
          // ÌäπÏ†ï Í∑úÏπô Î¨¥Ïãú ÏÑ§Ï†ï (ÌïÑÏöîÏóê Îî∞Îùº)
          'WCAG2AA.Principle4.Guideline4_1.4_1_2.H91.A.EmptyNoId'
        ],
        chromeLaunchConfig: {
          args: ['--no-sandbox', '--disable-dev-shm-usage']
        }
      };
      
      // Pa11y Ïã§Ìñâ
      const result = execSync(
        `pa11y ${this.baseUrl} --reporter json --standard ${pa11yConfig.standard}`,
        { encoding: 'utf8' }
      );
      
      const pa11yResults = JSON.parse(result);
      
      // Í≤∞Í≥º Ï≤òÎ¶¨
      const violationsBySeverity = pa11yResults.reduce((acc, issue) => {
        const severity = this.mapPa11ySeverity(issue.type);
        acc[severity] = (acc[severity] || 0) + 1;
        return acc;
      }, {});
      
      const totalIssues = pa11yResults.length;
      const complianceRate = Math.max(0, Math.round((1 - totalIssues / 100) * 100));
      
      this.results.pa11y = {
        totalIssues,
        issues: pa11yResults.map(issue => ({
          type: issue.type,
          code: issue.code,
          message: issue.message,
          context: issue.context,
          selector: issue.selector,
          runner: issue.runner,
          runnerExtras: issue.runnerExtras
        })),
        violationsBySeverity,
        complianceRate,
        timestamp: new Date().toISOString()
      };
      
      // Í≤∞Í≥º Ï†ÄÏû•
      fs.writeFileSync(
        path.join(this.outputDir, 'pa11y-results.json'),
        JSON.stringify(this.results.pa11y, null, 2)
      );
      
      console.log('  ‚úÖ Pa11y Ïä§Ï∫î ÏôÑÎ£å');
      
    } catch (error) {
      console.warn('  ‚ö†Ô∏è Pa11y Ïã§Ìñâ Ïã§Ìå®:', error.message);
      this.results.pa11y = { error: error.message };
    }
  }

  /**
   * Lighthouse Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨ Ïã§Ìñâ
   */
  async runLighthouseAccessibility() {
    console.log('üîç Lighthouse Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨ Ï§ë...');
    
    try {
      // Lighthouse CLI ÏÑ§Ïπò ÌôïÏù∏
      execSync('which lighthouse', { stdio: 'ignore' });
    } catch {
      console.warn('  ‚ö†Ô∏è LighthouseÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïÑ Í±¥ÎÑàÎúÅÎãàÎã§.');
      this.results.lighthouse = { skipped: true };
      return;
    }
    
    try {
      const result = execSync(
        `lighthouse ${this.baseUrl} --only-categories=accessibility --output=json --chrome-flags="--headless"`,
        { encoding: 'utf8' }
      );
      
      const lighthouseResult = JSON.parse(result);
      const accessibilityCategory = lighthouseResult.categories.accessibility;
      const audits = lighthouseResult.audits;
      
      // Ï†ëÍ∑ºÏÑ± Í¥ÄÎ†® Í∞êÏÇ¨ Ìï≠Î™© Ï∂îÏ∂ú
      const accessibilityAudits = {};
      Object.entries(audits).forEach(([auditId, audit]) => {
        if (audit.id.includes('accessibility') || audit.score !== null) {
          accessibilityAudits[auditId] = {
            score: audit.score,
            displayValue: audit.displayValue,
            title: audit.title,
            description: audit.description
          };
        }
      });
      
      this.results.lighthouse = {
        score: Math.round(accessibilityCategory.score * 100),
        audits: accessibilityAudits,
        timestamp: new Date().toISOString()
      };
      
      // Í≤∞Í≥º Ï†ÄÏû•
      fs.writeFileSync(
        path.join(this.outputDir, 'lighthouse-accessibility.json'),
        JSON.stringify(this.results.lighthouse, null, 2)
      );
      
      console.log('  ‚úÖ Lighthouse Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨ ÏôÑÎ£å');
      
    } catch (error) {
      console.warn('  ‚ö†Ô∏è Lighthouse Ïã§Ìñâ Ïã§Ìå®:', error.message);
      this.results.lighthouse = { error: error.message };
    }
  }

  /**
   * ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÖåÏä§Ìä∏
   */
  async testKeyboardNavigation() {
    console.log('‚å®Ô∏è ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÖåÏä§Ìä∏ Ï§ë...');
    
    const browser = await chromium.launch();
    const page = await browser.newPage();
    
    try {
      await page.goto(this.baseUrl, { waitUntil: 'networkidle' });
      
      // Î™®Îì† Ìè¨Ïª§Ïä§ Í∞ÄÎä•Ìïú ÏöîÏÜå Ï∞æÍ∏∞
      const focusableElements = await page.evaluate(() => {
        const selector = [
          'a[href]',
          'button:not([disabled])',
          'textarea:not([disabled])',
          'input:not([disabled])',
          'select:not([disabled])',
          '[tabindex]:not([tabindex="-1"])'
        ].join(',');
        
        return Array.from(document.querySelectorAll(selector))
          .map(el => ({
            tagName: el.tagName,
            type: el.type,
            id: el.id,
            className: el.className,
            ariaLabel: el.getAttribute('aria-label'),
            tabIndex: el.tabIndex
          }));
      });
      
      // ÌÉ≠ ÏàúÏÑú ÌÖåÏä§Ìä∏
      const tabOrder = [];
      let tabCount = 0;
      const maxTabs = Math.min(focusableElements.length + 5, 50); // Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ
      
      // Ï≤´ Î≤àÏß∏ ÏöîÏÜåÏóê Ìè¨Ïª§Ïä§
      await page.keyboard.press('Tab');
      
      while (tabCount < maxTabs) {
        const activeElement = await page.evaluate(() => {
          const el = document.activeElement;
          return el ? {
            tagName: el.tagName,
            id: el.id,
            className: el.className,
            tabIndex: el.tabIndex,
            isVisible: el.offsetParent !== null
          } : null;
        });
        
        if (activeElement && activeElement.isVisible) {
          tabOrder.push(activeElement);
        }
        
        await page.keyboard.press('Tab');
        tabCount++;
        
        // BodyÎ°ú ÎèåÏïÑÏò§Î©¥ Ï¢ÖÎ£å
        const currentFocus = await page.evaluate(() => document.activeElement.tagName);
        if (currentFocus === 'BODY' && tabCount > focusableElements.length) {
          break;
        }
      }
      
      // ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Í≤∞Í≥º Î∂ÑÏÑù
      const navigationScore = this.calculateKeyboardScore(focusableElements, tabOrder);
      
      this.results.keyboard = {
        focusableElementsCount: focusableElements.length,
        tabOrder,
        navigationScore,
        issues: this.identifyKeyboardIssues(focusableElements, tabOrder),
        timestamp: new Date().toISOString()
      };
      
      // Í≤∞Í≥º Ï†ÄÏû•
      fs.writeFileSync(
        path.join(this.outputDir, 'keyboard-navigation.json'),
        JSON.stringify(this.results.keyboard, null, 2)
      );
      
      console.log('  ‚úÖ ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÌÖåÏä§Ìä∏ ÏôÑÎ£å');
      
    } finally {
      await browser.close();
    }
  }

  /**
   * ÏÉâÏÉÅ ÎåÄÎπÑ Í≤ÄÏÇ¨
   */
  async checkColorContrast() {
    console.log('üé® ÏÉâÏÉÅ ÎåÄÎπÑ Í≤ÄÏÇ¨ Ï§ë...');
    
    const browser = await chromium.launch();
    const page = await browser.newPage();
    
    try {
      await page.goto(this.baseUrl, { waitUntil: 'networkidle' });
      
      // ÌÖçÏä§Ìä∏ ÏöîÏÜåÎì§Ïùò ÏÉâÏÉÅ ÎåÄÎπÑ Í≤ÄÏÇ¨
      const contrastResults = await page.evaluate((wcagLevel) => {
        const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, a, button, label, li');
        const results = [];
        
        Array.from(textElements).forEach(element => {
          const styles = window.getComputedStyle(element);
          const textColor = styles.color;
          const backgroundColor = styles.backgroundColor;
          
          // Ìà¨Î™ÖÌïú Î∞∞Í≤ΩÏÉâÏù∏ Í≤ΩÏö∞ Î∂ÄÎ™® ÏöîÏÜåÏùò Î∞∞Í≤ΩÏÉâ Ï∞æÍ∏∞
          let bgColor = backgroundColor;
          let parent = element.parentElement;
          
          while (parent && (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent')) {
            const parentStyles = window.getComputedStyle(parent);
            bgColor = parentStyles.backgroundColor;
            parent = parent.parentElement;
          }
          
          // Í∏∞Î≥∏ Î∞∞Í≤ΩÏÉâ ÏÑ§Ï†ï
          if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent') {
            bgColor = 'rgb(255, 255, 255)'; // Í∏∞Î≥∏ Ìù∞ÏÉâ
          }
          
          results.push({
            element: {
              tagName: element.tagName,
              id: element.id,
              className: element.className,
              text: element.textContent.trim().substring(0, 50)
            },
            colors: {
              text: textColor,
              background: bgColor
            },
            fontSize: parseFloat(styles.fontSize),
            fontWeight: styles.fontWeight
          });
        });
        
        return results;
      }, this.wcagLevel);
      
      // ÏÉâÏÉÅ ÎåÄÎπÑ ÎπÑÏú® Í≥ÑÏÇ∞
      const contrastAnalysis = contrastResults.map(item => {
        const contrast = this.calculateContrastRatio(item.colors.text, item.colors.background);
        const requiredRatio = this.getRequiredContrastRatio(item.fontSize, item.fontWeight);
        
        return {
          ...item,
          contrast,
          requiredRatio,
          passed: contrast >= requiredRatio,
          wcagLevel: contrast >= 4.5 ? 'AA' : contrast >= 3 ? 'A' : 'Fail'
        };
      });
      
      const passedContrast = contrastAnalysis.filter(item => item.passed).length;
      const totalElements = contrastAnalysis.length;
      const contrastScore = totalElements > 0 ? Math.round((passedContrast / totalElements) * 100) : 100;
      
      this.results.colorContrast = {
        totalElements,
        passedElements: passedContrast,
        failedElements: totalElements - passedContrast,
        contrastScore,
        details: contrastAnalysis.filter(item => !item.passed), // Ïã§Ìå®Ìïú Ìï≠Î™©Îßå Ï†ÄÏû•
        timestamp: new Date().toISOString()
      };
      
      // Í≤∞Í≥º Ï†ÄÏû•
      fs.writeFileSync(
        path.join(this.outputDir, 'color-contrast.json'),
        JSON.stringify(this.results.colorContrast, null, 2)
      );
      
      console.log('  ‚úÖ ÏÉâÏÉÅ ÎåÄÎπÑ Í≤ÄÏÇ¨ ÏôÑÎ£å');
      
    } finally {
      await browser.close();
    }
  }

  /**
   * Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ìò∏ÌôòÏÑ± Í≤ÄÏÇ¨
   */
  async testScreenReaderCompatibility() {
    console.log('üì¢ Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ìò∏ÌôòÏÑ± Í≤ÄÏÇ¨ Ï§ë...');
    
    const browser = await chromium.launch();
    const page = await browser.newPage();
    
    try {
      await page.goto(this.baseUrl, { waitUntil: 'networkidle' });
      
      // ARIA ÏÜçÏÑ± Î∞è ÏãúÎß®Ìã± ÏöîÏÜå Í≤ÄÏÇ¨
      const ariaAnalysis = await page.evaluate(() => {
        const results = {
          ariaLabels: 0,
          ariaDescriptions: 0,
          ariaRoles: 0,
          semanticElements: 0,
          images: { total: 0, withAlt: 0 },
          forms: { total: 0, withLabels: 0 },
          headings: { total: 0, properStructure: true },
          landmarks: 0
        };
        
        // ARIA Î†àÏù¥Î∏î Í≤ÄÏÇ¨
        results.ariaLabels = document.querySelectorAll('[aria-label]').length;
        results.ariaDescriptions = document.querySelectorAll('[aria-describedby]').length;
        results.ariaRoles = document.querySelectorAll('[role]').length;
        
        // ÏãúÎß®Ìã± ÏöîÏÜå Í≤ÄÏÇ¨
        const semanticTags = ['header', 'nav', 'main', 'section', 'article', 'aside', 'footer'];
        results.semanticElements = semanticTags.reduce((count, tag) => 
          count + document.querySelectorAll(tag).length, 0
        );
        
        // Ïù¥ÎØ∏ÏßÄ alt ÏÜçÏÑ± Í≤ÄÏÇ¨
        const images = document.querySelectorAll('img');
        results.images.total = images.length;
        results.images.withAlt = Array.from(images).filter(img => 
          img.hasAttribute('alt') && img.alt.trim() !== ''
        ).length;
        
        // Ìèº Î†àÏù¥Î∏î Í≤ÄÏÇ¨
        const inputs = document.querySelectorAll('input, select, textarea');
        results.forms.total = inputs.length;
        results.forms.withLabels = Array.from(inputs).filter(input => {
          const id = input.id;
          const hasLabel = id && document.querySelector(`label[for="${id}"]`);
          const hasAriaLabel = input.hasAttribute('aria-label');
          const hasAriaLabelledby = input.hasAttribute('aria-labelledby');
          
          return hasLabel || hasAriaLabel || hasAriaLabelledby;
        }).length;
        
        // Ìó§Îî© Íµ¨Ï°∞ Í≤ÄÏÇ¨
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        results.headings.total = headings.length;
        
        let previousLevel = 0;
        results.headings.properStructure = Array.from(headings).every(heading => {
          const currentLevel = parseInt(heading.tagName.charAt(1));
          const isValidLevel = currentLevel <= previousLevel + 1;
          previousLevel = currentLevel;
          return isValidLevel;
        });
        
        // ÎûúÎìúÎßàÌÅ¨ Í≤ÄÏÇ¨
        const landmarks = document.querySelectorAll('[role="banner"], [role="navigation"], [role="main"], [role="contentinfo"], [role="complementary"], [role="search"]');
        results.landmarks = landmarks.length;
        
        return results;
      });
      
      // Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ï†êÏàò Í≥ÑÏÇ∞
      const screenReaderScore = this.calculateScreenReaderScore(ariaAnalysis);
      
      this.results.screenReader = {
        ...ariaAnalysis,
        score: screenReaderScore,
        recommendations: this.generateScreenReaderRecommendations(ariaAnalysis),
        timestamp: new Date().toISOString()
      };
      
      // Í≤∞Í≥º Ï†ÄÏû•
      fs.writeFileSync(
        path.join(this.outputDir, 'screen-reader-compatibility.json'),
        JSON.stringify(this.results.screenReader, null, 2)
      );
      
      console.log('  ‚úÖ Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ìò∏ÌôòÏÑ± Í≤ÄÏÇ¨ ÏôÑÎ£å');
      
    } finally {
      await browser.close();
    }
  }

  /**
   * axe Ïã¨Í∞ÅÎèÑ Îß§Ìïë
   */
  mapAxeSeverity(impact) {
    const mapping = {
      'critical': 'critical',
      'serious': 'serious',
      'moderate': 'moderate',
      'minor': 'minor'
    };
    return mapping[impact] || 'minor';
  }

  /**
   * Pa11y Ïã¨Í∞ÅÎèÑ Îß§Ìïë
   */
  mapPa11ySeverity(type) {
    const mapping = {
      'error': 'serious',
      'warning': 'moderate',
      'notice': 'minor'
    };
    return mapping[type] || 'minor';
  }

  /**
   * ÌÇ§Î≥¥Îìú Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateKeyboardScore(focusableElements, tabOrder) {
    if (focusableElements.length === 0) return 100;
    
    const validTabElements = tabOrder.filter(el => el && el.isVisible);
    const coverage = Math.min(validTabElements.length / focusableElements.length, 1);
    
    return Math.round(coverage * 100);
  }

  /**
   * ÌÇ§Î≥¥Îìú Ïù¥Ïäà ÏãùÎ≥Ñ
   */
  identifyKeyboardIssues(focusableElements, tabOrder) {
    const issues = [];
    
    // Ìè¨Ïª§Ïä§ Í∞ÄÎä•Ìïú ÏöîÏÜåÍ∞Ä ÌÉ≠ ÏàúÏÑúÏóê ÏóÜÎäî Í≤ΩÏö∞
    const tabOrderIds = new Set(tabOrder.map(el => el.id).filter(Boolean));
    const missingElements = focusableElements.filter(el => 
      el.id && !tabOrderIds.has(el.id)
    );
    
    if (missingElements.length > 0) {
      issues.push({
        type: 'missing-tab-order',
        message: `${missingElements.length}Í∞ú ÏöîÏÜåÍ∞Ä ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖòÏóêÏÑú ÎàÑÎùΩÎê®`,
        elements: missingElements
      });
    }
    
    // ÏûòÎ™ªÎêú tabindex Í∞í Í≤ÄÏÇ¨
    const negativeTabIndex = focusableElements.filter(el => el.tabIndex < 0);
    if (negativeTabIndex.length > 0) {
      issues.push({
        type: 'negative-tabindex',
        message: `${negativeTabIndex.length}Í∞ú ÏöîÏÜåÏóê ÏùåÏàò tabindex ÏÑ§Ï†ïÎê®`,
        elements: negativeTabIndex
      });
    }
    
    return issues;
  }

  /**
   * ÏÉâÏÉÅ ÎåÄÎπÑ ÎπÑÏú® Í≥ÑÏÇ∞
   */
  calculateContrastRatio(textColor, backgroundColor) {
    // Í∞ÑÎã®Ìïú Íµ¨ÌòÑ (Ïã§Ï†úÎ°úÎäî Îçî Ï†ïÌôïÌïú Í≥ÑÏÇ∞Ïù¥ ÌïÑÏöî)
    const getRGB = (color) => {
      const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (match) {
        return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
      }
      return [0, 0, 0]; // Í∏∞Î≥∏Í∞í
    };
    
    const getLuminance = (rgb) => {
      const [r, g, b] = rgb.map(c => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };
    
    const textRGB = getRGB(textColor);
    const bgRGB = getRGB(backgroundColor);
    
    const textLuminance = getLuminance(textRGB);
    const bgLuminance = getLuminance(bgRGB);
    
    const lighter = Math.max(textLuminance, bgLuminance);
    const darker = Math.min(textLuminance, bgLuminance);
    
    return (lighter + 0.05) / (darker + 0.05);
  }

  /**
   * ÌïÑÏöîÌïú ÎåÄÎπÑ ÎπÑÏú® Í≥ÑÏÇ∞
   */
  getRequiredContrastRatio(fontSize, fontWeight) {
    const isLargeText = fontSize >= 18 || (fontSize >= 14 && (fontWeight === 'bold' || parseInt(fontWeight) >= 700));
    
    if (this.wcagLevel === 'AAA') {
      return isLargeText ? 4.5 : 7;
    } else {
      return isLargeText ? 3 : 4.5;
    }
  }

  /**
   * Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateScreenReaderScore(analysis) {
    let score = 0;
    let totalChecks = 0;
    
    // Ïù¥ÎØ∏ÏßÄ alt ÏÜçÏÑ±
    if (analysis.images.total > 0) {
      score += (analysis.images.withAlt / analysis.images.total) * 20;
      totalChecks += 20;
    }
    
    // Ìèº Î†àÏù¥Î∏î
    if (analysis.forms.total > 0) {
      score += (analysis.forms.withLabels / analysis.forms.total) * 25;
      totalChecks += 25;
    }
    
    // Ìó§Îî© Íµ¨Ï°∞
    if (analysis.headings.total > 0) {
      score += analysis.headings.properStructure ? 15 : 0;
      totalChecks += 15;
    }
    
    // ARIA ÏÇ¨Ïö©
    const ariaScore = Math.min((analysis.ariaLabels + analysis.ariaDescriptions + analysis.ariaRoles) / 5, 1) * 20;
    score += ariaScore;
    totalChecks += 20;
    
    // ÏãúÎß®Ìã± ÏöîÏÜå
    const semanticScore = Math.min(analysis.semanticElements / 3, 1) * 20;
    score += semanticScore;
    totalChecks += 20;
    
    return totalChecks > 0 ? Math.round(score / totalChecks * 100) : 100;
  }

  /**
   * Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
   */
  generateScreenReaderRecommendations(analysis) {
    const recommendations = [];
    
    if (analysis.images.total > 0 && analysis.images.withAlt / analysis.images.total < 1) {
      recommendations.push('Î™®Îì† Ïù¥ÎØ∏ÏßÄÏóê ÏùòÎØ∏ÏûàÎäî alt ÏÜçÏÑ±ÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.');
    }
    
    if (analysis.forms.total > 0 && analysis.forms.withLabels / analysis.forms.total < 1) {
      recommendations.push('Î™®Îì† Ìèº ÏöîÏÜåÏóê Ï†ÅÏ†àÌïú Î†àÏù¥Î∏îÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.');
    }
    
    if (!analysis.headings.properStructure) {
      recommendations.push('Ìó§Îî© ÌÉúÍ∑∏Ïùò ÏàúÏÑúÎ•º Ïò¨Î∞îÎ•¥Í≤å Íµ¨ÏÑ±ÌïòÏÑ∏Ïöî (h1 ‚Üí h2 ‚Üí h3).');
    }
    
    if (analysis.ariaLabels + analysis.ariaDescriptions < 3) {
      recommendations.push('ÏÉÅÌò∏ÏûëÏö© ÏöîÏÜåÏóê ARIA Î†àÏù¥Î∏îÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.');
    }
    
    if (analysis.semanticElements < 3) {
      recommendations.push('Îçî ÎßéÏùÄ ÏãúÎß®Ìã± HTML ÏöîÏÜåÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî (header, nav, main Îì±).');
    }
    
    if (analysis.landmarks < 2) {
      recommendations.push('ÌéòÏù¥ÏßÄ Íµ¨Ï°∞Î•º ÎÇòÌÉÄÎÇ¥Îäî ÎûúÎìúÎßàÌÅ¨ Ïó≠Ìï†ÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.');
    }
    
    return recommendations;
  }

  /**
   * ÏûÑÍ≥ÑÍ∞í Í≤ÄÏ¶ù
   */
  validateThresholds() {
    console.log('üéØ Ï†ëÍ∑ºÏÑ± ÏûÑÍ≥ÑÍ∞í Í≤ÄÏ¶ù Ï§ë...');
    
    const failures = [];
    
    // axe-core Í≤∞Í≥º Í≤ÄÏ¶ù
    if (this.results.axe.summary) {
      const axeCompliance = this.results.axe.summary.complianceRate;
      if (axeCompliance < this.thresholds.compliance) {
        failures.push(`axe-core Ï§ÄÏàòÏú®: ${axeCompliance}% < ${this.thresholds.compliance}%`);
      }
      
      // Ïã¨Í∞ÅÎèÑÎ≥Ñ ÏúÑÎ∞ò Í≤ÄÏ¶ù
      const violations = this.results.axe.summary.violationsBySeverity;
      Object.entries(this.thresholds.violations).forEach(([severity, threshold]) => {
        const count = violations[severity] || 0;
        if (count > threshold) {
          failures.push(`${severity} ÏàòÏ§Ä ÏúÑÎ∞ò: ${count}Í∞ú > ${threshold}Í∞ú`);
        }
      });
    }
    
    // Pa11y Í≤∞Í≥º Í≤ÄÏ¶ù
    if (this.results.pa11y.complianceRate !== undefined) {
      const pa11yCompliance = this.results.pa11y.complianceRate;
      if (pa11yCompliance < this.thresholds.compliance) {
        failures.push(`Pa11y Ï§ÄÏàòÏú®: ${pa11yCompliance}% < ${this.thresholds.compliance}%`);
      }
    }
    
    // ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Í≤ÄÏ¶ù
    if (this.results.keyboard.navigationScore < this.thresholds.keyboardNavigation) {
      failures.push(`ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò: ${this.results.keyboard.navigationScore}% < ${this.thresholds.keyboardNavigation}%`);
    }
    
    // ÏÉâÏÉÅ ÎåÄÎπÑ Í≤ÄÏ¶ù
    if (this.results.colorContrast.contrastScore !== undefined) {
      const contrastRate = this.results.colorContrast.contrastScore;
      const requiredRate = 90; // 90% Ïù¥ÏÉÅ Í∂åÏû•
      if (contrastRate < requiredRate) {
        failures.push(`ÏÉâÏÉÅ ÎåÄÎπÑ ÌÜµÍ≥ºÏú®: ${contrastRate}% < ${requiredRate}%`);
      }
    }
    
    this.results.passed = failures.length === 0;
    this.results.failures = failures;
    
    // Ï†ÑÏ≤¥ ÏöîÏïΩ ÏÉùÏÑ±
    this.results.summary = {
      overallCompliance: this.calculateOverallCompliance(),
      totalViolations: this.calculateTotalViolations(),
      recommendations: this.generateOverallRecommendations()
    };
    
    if (this.results.passed) {
      console.log('  ‚úÖ Î™®Îì† Ï†ëÍ∑ºÏÑ± ÏûÑÍ≥ÑÍ∞í ÌÜµÍ≥º');
    } else {
      console.log('  ‚ùå Ï†ëÍ∑ºÏÑ± ÏûÑÍ≥ÑÍ∞í Ïã§Ìå®:');
      failures.forEach(failure => console.log(`    - ${failure}`));
    }
  }

  /**
   * Ï†ÑÏ≤¥ Ï§ÄÏàòÏú® Í≥ÑÏÇ∞
   */
  calculateOverallCompliance() {
    const scores = [];
    
    if (this.results.axe.summary?.complianceRate !== undefined) {
      scores.push(this.results.axe.summary.complianceRate);
    }
    
    if (this.results.pa11y.complianceRate !== undefined) {
      scores.push(this.results.pa11y.complianceRate);
    }
    
    if (this.results.lighthouse.score !== undefined) {
      scores.push(this.results.lighthouse.score);
    }
    
    if (this.results.keyboard.navigationScore !== undefined) {
      scores.push(this.results.keyboard.navigationScore);
    }
    
    if (this.results.colorContrast.contrastScore !== undefined) {
      scores.push(this.results.colorContrast.contrastScore);
    }
    
    if (this.results.screenReader.score !== undefined) {
      scores.push(this.results.screenReader.score);
    }
    
    return scores.length > 0 ? Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length) : 100;
  }

  /**
   * Ï†ÑÏ≤¥ ÏúÑÎ∞òÏÇ¨Ìï≠ Í∞úÏàò Í≥ÑÏÇ∞
   */
  calculateTotalViolations() {
    let total = 0;
    
    if (this.results.axe.summary?.totalViolations) {
      total += this.results.axe.summary.totalViolations;
    }
    
    if (this.results.pa11y.totalIssues) {
      total += this.results.pa11y.totalIssues;
    }
    
    return total;
  }

  /**
   * Ï†ÑÏ≤¥ Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
   */
  generateOverallRecommendations() {
    const recommendations = [];
    
    if (this.results.axe.summary?.violationsBySeverity.critical > 0) {
      recommendations.push('Ï§ëÏöîÌïú Ï†ëÍ∑ºÏÑ± ÏúÑÎ∞òÏÇ¨Ìï≠ÏùÑ Ï¶âÏãú ÏàòÏ†ïÌïòÏÑ∏Ïöî.');
    }
    
    if (this.results.colorContrast.failedElements > 0) {
      recommendations.push('ÏÉâÏÉÅ ÎåÄÎπÑÍ∞Ä Î∂ÄÏ°±Ìïú ÌÖçÏä§Ìä∏Î•º Í∞úÏÑ†ÌïòÏÑ∏Ïöî.');
    }
    
    if (this.results.keyboard.issues?.length > 0) {
      recommendations.push('ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÏÑ∏Ïöî.');
    }
    
    if (this.results.screenReader.recommendations?.length > 0) {
      recommendations.push(...this.results.screenReader.recommendations);
    }
    
    return recommendations;
  }

  /**
   * Ï†ëÍ∑ºÏÑ± Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
   */
  async generateReport() {
    console.log('üìÑ Ï†ëÍ∑ºÏÑ± Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ï§ë...');
    
    const report = this.generateMarkdownReport();
    
    // Markdown Î≥¥Í≥†ÏÑú Ï†ÄÏû•
    fs.writeFileSync(
      path.join(this.outputDir, 'accessibility-report.md'),
      report
    );
    
    // JSON ÏöîÏïΩ Ï†ÄÏû•
    fs.writeFileSync(
      path.join(this.outputDir, 'accessibility-summary.json'),
      JSON.stringify(this.results, null, 2)
    );
    
    console.log('  ‚úÖ Ï†ëÍ∑ºÏÑ± Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏôÑÎ£å');
  }

  /**
   * Markdown ÌòïÏãùÏùò Ï†ëÍ∑ºÏÑ± Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
   */
  generateMarkdownReport() {
    const { axe, pa11y, lighthouse, keyboard, colorContrast, screenReader, summary } = this.results;
    
    let report = `# ‚ôø Ï¢ÖÌï© Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ Î≥¥Í≥†ÏÑú\n\n`;
    report += `**ÏÉùÏÑ± ÏãúÍ∞Ñ**: ${new Date().toLocaleString('ko-KR')}\n`;
    report += `**WCAG Í∏∞Ï§Ä**: ${this.wcagVersion} ${this.wcagLevel}\n\n`;
    
    // Ï†ÑÏ≤¥ ÏöîÏïΩ
    report += `## üìä Ï†ÑÏ≤¥ ÏöîÏïΩ\n\n`;
    report += `- **Ï†ÑÏ≤¥ Ï§ÄÏàòÏú®**: ${summary.overallCompliance}%\n`;
    report += `- **Ï¥ù ÏúÑÎ∞òÏÇ¨Ìï≠**: ${summary.totalViolations}Í∞ú\n`;
    report += `- **Ï†ÑÏ≤¥ ÌÜµÍ≥º**: ${this.results.passed ? '‚úÖ Ïòà' : '‚ùå ÏïÑÎãàÏò§'}\n\n`;
    
    // axe-core Í≤∞Í≥º
    if (axe.summary) {
      report += `## üîç axe-core Í≤∞Í≥º\n\n`;
      report += `- **Ï§ÄÏàòÏú®**: ${axe.summary.complianceRate}%\n`;
      report += `- **Ï¥ù ÌÖåÏä§Ìä∏**: ${axe.summary.totalTests}Í∞ú\n`;
      report += `- **ÌÜµÍ≥º**: ${axe.summary.totalPasses}Í∞ú\n`;
      report += `- **ÏúÑÎ∞ò**: ${axe.summary.totalViolations}Í∞ú\n\n`;
      
      if (axe.summary.violationsBySeverity) {
        report += `### Ïã¨Í∞ÅÎèÑÎ≥Ñ ÏúÑÎ∞òÏÇ¨Ìï≠\n\n`;
        Object.entries(axe.summary.violationsBySeverity).forEach(([severity, count]) => {
          report += `- **${severity.toUpperCase()}**: ${count}Í∞ú\n`;
        });
        report += `\n`;
      }
    }
    
    // Lighthouse Í≤∞Í≥º
    if (lighthouse.score !== undefined) {
      report += `## üîç Lighthouse Ï†ëÍ∑ºÏÑ± Ï†êÏàò\n\n`;
      report += `**Ï†êÏàò**: ${lighthouse.score}%\n\n`;
    }
    
    // ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
    if (keyboard.navigationScore !== undefined) {
      report += `## ‚å®Ô∏è ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò\n\n`;
      report += `- **ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ï†êÏàò**: ${keyboard.navigationScore}%\n`;
      report += `- **Ìè¨Ïª§Ïä§ Í∞ÄÎä• ÏöîÏÜå**: ${keyboard.focusableElementsCount}Í∞ú\n`;
      
      if (keyboard.issues?.length > 0) {
        report += `\n### Î∞úÍ≤¨Îêú Î¨∏Ï†ú\n\n`;
        keyboard.issues.forEach(issue => {
          report += `- ${issue.message}\n`;
        });
        report += `\n`;
      }
    }
    
    // ÏÉâÏÉÅ ÎåÄÎπÑ
    if (colorContrast.contrastScore !== undefined) {
      report += `## üé® ÏÉâÏÉÅ ÎåÄÎπÑ\n\n`;
      report += `- **ÎåÄÎπÑ Ï†êÏàò**: ${colorContrast.contrastScore}%\n`;
      report += `- **Í≤ÄÏÇ¨ ÏöîÏÜå**: ${colorContrast.totalElements}Í∞ú\n`;
      report += `- **ÌÜµÍ≥º**: ${colorContrast.passedElements}Í∞ú\n`;
      report += `- **Ïã§Ìå®**: ${colorContrast.failedElements}Í∞ú\n\n`;
    }
    
    // Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ìò∏ÌôòÏÑ±
    if (screenReader.score !== undefined) {
      report += `## üì¢ Ïä§ÌÅ¨Î¶∞ Î¶¨Îçî Ìò∏ÌôòÏÑ±\n\n`;
      report += `- **Ìò∏ÌôòÏÑ± Ï†êÏàò**: ${screenReader.score}%\n`;
      report += `- **ARIA Î†àÏù¥Î∏î**: ${screenReader.ariaLabels}Í∞ú\n`;
      report += `- **ÏãúÎß®Ìã± ÏöîÏÜå**: ${screenReader.semanticElements}Í∞ú\n`;
      report += `- **Ïù¥ÎØ∏ÏßÄ alt**: ${screenReader.images.withAlt}/${screenReader.images.total}Í∞ú\n`;
      report += `- **Ìèº Î†àÏù¥Î∏î**: ${screenReader.forms.withLabels}/${screenReader.forms.total}Í∞ú\n\n`;
    }
    
    // Í∂åÏû•ÏÇ¨Ìï≠
    if (summary.recommendations?.length > 0) {
      report += `## üí° Í∂åÏû•ÏÇ¨Ìï≠\n\n`;
      summary.recommendations.forEach(recommendation => {
        report += `- ${recommendation}\n`;
      });
      report += `\n`;
    }
    
    // Ï†ÑÏ≤¥ Í≤∞Í≥º
    report += `## üéØ Ï†ÑÏ≤¥ Í≤∞Í≥º\n\n`;
    if (this.results.passed) {
      report += `‚úÖ **Î™®Îì† Ï†ëÍ∑ºÏÑ± ÏûÑÍ≥ÑÍ∞íÏùÑ ÌÜµÍ≥ºÌñàÏäµÎãàÎã§!**\n\n`;
      report += `Ïõπ Ï†ëÍ∑ºÏÑ± Í∏∞Ï§ÄÏùÑ Ï∂©Ï°±ÌïòÏó¨ Î™®Îì† ÏÇ¨Ïö©ÏûêÍ∞Ä Ìé∏Î¶¨ÌïòÍ≤å Ïù¥Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.\n`;
    } else {
      report += `‚ùå **ÏùºÎ∂Ä Ï†ëÍ∑ºÏÑ± Í∏∞Ï§ÄÏùÑ Ï∂©Ï°±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.**\n\n`;
      report += `Í∞úÏÑ†Ïù¥ ÌïÑÏöîÌïú Ìï≠Î™©:\n`;
      this.results.failures.forEach(failure => {
        report += `- ${failure}\n`;
      });
    }
    
    return report;
  }

  /**
   * Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÌôïÏù∏ Î∞è ÏÉùÏÑ±
   */
  async ensureOutputDirectory() {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }
}

// CLIÏóêÏÑú ÏßÅÏ†ë Ïã§ÌñâÌï† Îïå
if (require.main === module) {
  const args = process.argv.slice(2);
  const options = {};
  
  // Î™ÖÎ†πÌñâ Ïù∏Ïàò ÌååÏã±
  for (let i = 0; i < args.length; i += 2) {
    const key = args[i].replace('--', '');
    const value = args[i + 1];
    
    if (key && value) {
      if (['compliance', 'critical', 'serious', 'moderate', 'minor', 'colorContrast', 'keyboardNavigation'].includes(key)) {
        options[key] = parseFloat(value);
      } else {
        options[key] = value;
      }
    }
  }
  
  const tester = new AccessibilityTester(options);
  
  tester.run()
    .then(results => {
      console.log('\n‚ôø Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ Í≤∞Í≥º:');
      console.log(`Ï†ÑÏ≤¥ ÌÜµÍ≥º: ${results.passed ? '‚úÖ' : '‚ùå'}`);
      console.log(`Ï†ÑÏ≤¥ Ï§ÄÏàòÏú®: ${results.summary.overallCompliance}%`);
      
      if (!results.passed) {
        process.exit(1);
      }
    })
    .catch(error => {
      console.error('Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏ Ïã§Ìñâ Ïã§Ìå®:', error);
      process.exit(1);
    });
}

module.exports = AccessibilityTester;