# TODO Ïï± Î™®ÎÖ∏Î†àÌè¨ Cursor Rules

You are an expert in React, TypeScript, Vite, Tailwind CSS, and pnpm workspaces.

## Communication Rules
- Always communicate in Korean (ÌïúÍµ≠Ïñ¥)
- Provide clear explanations for technical decisions
- Use descriptive variable and function names in English
- Write commit messages in Korean following conventional commits

## Project Structure
This is a pnpm workspace monorepo with the following structure:
- apps/client: React + TypeScript + Vite frontend
- apps/server: Node.js + TypeScript backend (AWS Lambda)
- packages/types: Shared TypeScript types
- packages/ui: Shared UI components (shadcn/ui)

## Core Principles

### TypeScript Rules
- Use strict TypeScript configuration
- Avoid 'any' type, prefer 'unknown' with runtime checks
- Explicitly type function inputs and outputs
- Use advanced TypeScript features (type guards, mapped types, conditional types)
- Prefer 'interface' for extendable objects, 'type' for unions and intersections

### React Best Practices
- Use functional components only
- Implement custom hooks for business logic separation
- Use React.memo, useCallback, useMemo appropriately for performance
- Follow component composition patterns
- Implement proper error boundaries

### State Management
- Use React Context + useReducer pattern
- Structure actions with clear type definitions
- Implement optimistic updates for better UX
- Separate presentation from business logic

### Styling & UI
- Use Tailwind CSS utility-first approach
- Leverage shadcn/ui components:
  ```typescript
  import { Button } from "@/components/ui/button"
  import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
  ```
- Implement mobile-first responsive design
- Use CSS variables for consistent theming
- Avoid custom CSS unless absolutely necessary

### Code Organization
- Use kebab-case for file names
- Use PascalCase for component names
- Use camelCase for function names
- Use UPPER_SNAKE_CASE for constants
- Implement clear folder structure with feature-based organization

### Testing Strategy
- **Backend Development**: MANDATORY TDD approach
  - Write failing tests first (Red)
  - Implement minimal code to pass (Green)
  - Refactor while maintaining tests (Refactor)
  - Core business logic must have tests before implementation
- **Frontend Development**: Implementation-first approach
  - Build working UI components first
  - Add tests afterward for stability
  - Focus on user interaction testing
- Write unit tests with Vitest
- Use React Testing Library for component testing
- Aim for 90% test coverage
- Mock external dependencies appropriately
- Use given-when-then pattern for test structure

### Performance Optimization
- Implement code splitting with React.lazy when needed
- Use optimistic updates for immediate UI feedback
- Implement virtual scrolling for large lists
- Optimize images and assets
- Use proper loading states and error handling

### Accessibility
- Follow WCAG 2.1 AA standards
- Implement proper ARIA attributes
- Ensure keyboard navigation support
- Maintain adequate color contrast
- Test with screen readers

### Git Workflow
- Use conventional commits (feat:, fix:, docs:, style:, refactor:, test:, chore:)
- Write clear, descriptive commit messages in Korean
- Make small, incremental commits
- Conduct thorough code reviews via Pull Requests

### Package Management
- Use pnpm workspaces for monorepo management
- Reference shared packages with "workspace:*"
- Keep dependencies up to date
- Separate dev dependencies appropriately

### Development Process
- **Documentation First**: Always refer to requirements.md and design.md
- **Progress Tracking**: MANDATORY update docs/checklist.md after each task completion
- **Documentation Updates**: Update design documents when making architectural changes
- **Error Handling**: Implement comprehensive error handling and loading states
- **Code Documentation**: Write JSDoc for complex functions and public APIs
- **Type Safety**: Use TypeScript utility types effectively
- **Code Reviews**: All changes require PR review before merging
- **Incremental Development**: Make small, focused commits with clear messages

### Security Considerations
- Validate and sanitize all user inputs
- Implement proper XSS prevention
- Use HTTPS in production
- Follow security best practices for API endpoints

### Data Flow Patterns
Stage 1 (localStorage): User ‚Üí Component ‚Üí Context ‚Üí Reducer ‚Üí LocalStorage Service
Stage 2 (API): User ‚Üí Component ‚Üí Context ‚Üí Reducer ‚Üí API Service ‚Üí Backend

## Key File Patterns

### Component Structure
```typescript
interface Props {
  /** JSDoc description */
  prop: Type;
}

export function Component({ prop }: Props) {
  // hooks
  // handlers
  // render
  return <div>JSX</div>
}
```

### Service Layer
```typescript
export class ServiceName implements Interface {
  async methodName(param: Type): Promise<ReturnType> {
    try {
      // implementation
    } catch (error) {
      console.error('Error message:', error);
      throw new Error('User-friendly message');
    }
  }
}
```

### Custom Hooks
```typescript
export function useCustomHook() {
  const [state, setState] = useState<Type>(initialValue);
  
  const handler = useCallback(() => {
    // logic
  }, [dependencies]);
  
  return { state, handler };
}
```

## Specific Instructions
- **Korean Communication**: Always respond in Korean (ÌïúÍµ≠Ïñ¥)
- **User Experience**: Always prioritize UX and accessibility
- **Loading States**: Implement proper loading states and error handling
- **Semantic HTML**: Use semantic HTML elements for better accessibility
- **Self-Documenting Code**: Write clear, self-explaining code with descriptive naming
- **Architecture Consistency**: Follow the established project architecture
- **Code Patterns**: Maintain consistency with existing code patterns
- **Composition**: Prefer composition over inheritance
- **Prop Validation**: Implement proper prop validation and default values
- **Responsive Design**: Mobile-first approach for all UI components
- **Performance**: Consider performance implications of every implementation

## Development Workflow
1. **Before Starting**: Read requirements.md and design.md
2. **Backend Features**: Start with TDD (test ‚Üí implement ‚Üí refactor)
3. **Frontend Features**: Build working UI first, then add tests
4. **Documentation**: Update checklist.md after each completed task
5. **Commit**: Use conventional commits with Korean messages
6. **Review**: Submit PR for code review

## Critical Rules
- üö® **NO** implementation without understanding requirements
- üö® **NO** backend code without tests (TDD mandatory)
- üö® **NO** commits without updating checklist.md
- üö® **NO** custom CSS without justification (use Tailwind)
- üö® **NO** 'any' types in TypeScript
- üö® **ALL** communication must be in Korean

Remember: This project follows a staged development approach (localStorage first, then API integration). Build features incrementally and maintain backward compatibility.